// 가장 긴 증가하는 부분 수열 5 (14003) Platinum[5]




#1 
0) lower_bound && vector 사용하기
1) input && solution()
	// 제일 처음 백터에 0 넣어 놓고 
	// 입력 받으면서 받은 거랑 백터 마지막에 있는 거랑 비교
	// 입력이 더 크면 push_back
	// 입력이 더 작으면 lower_bound 이용해서 idx 찾고 값 변경
2) vector 사이즈 - 1 출력하고, 백터에 있는 값 맨 처음 값 빼고 출력 !
	// -1 은 제일 처음 넣어준 0 때문에



# 반례
6
1 3 4 5 2 4
>> 1 3 4 5 여야 되는데 1 2 4 5 가 나옴 ;; 

>> 그러면 최장 길이를 넘을 때마다 그 숫자들을 저장해 놓고
 마지막으로 저장된 수열을 출력해주는 것을 어떨까 ?

>> 이 반례는 해결했지만 그래도 실패임 ... 다른 반례들도 맞는데 ,,,



# 고려해볼만한 사항
input으로 들어올 수 있는 값이 -1,000,000,000 부터 1,000,000,000 까지임 



# 반례 2
9
3 1 4 6 2 2 0 3 6
>> 1 2 3 6 이 나와야 되는데 0 2 3 6 이 되고 
>> 2차원 vector 를 사용하기엔 메모리 초과나 시간초과의 우려가 있음
>> so .. 접근 방식이 틀림 ;; 


















