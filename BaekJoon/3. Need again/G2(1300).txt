// K번째 수 (1300) Gold[2]



#0 문제 이해하기
3 == 3 by 3 배열

1 2 3
2 4 6
3 6 9
그 행의 배수로 움직이네 

1 2 3 2 4 6 3 6 9 	1차원으로 변경 후
1 2 2 3 3 4 6 6 9	sort 후
0 1 2 3 4 5 6 7		idx 

6	결과 



#1 실패(2차원 배열 안만들어짐)
1) input()
	// 2차원 배열 만들어 놓기 
	// 잠시만 N <= 10^5 이긴한데 ,,, == 100,000
	// 너무 커서 안만들어짐 ... 
2) solve()
	// binary search 이용하기
	// for문으로 2차원 배열 upper bound 사용해서 cnt++
	// 그 cnt 가 출력하고자 하는 인덱스랑 맞을 때 결과 저장 && break
	// 뭐 이런식으로 
3) 결과 출력 




#2 (실패)
// 배열이 안만들어지면 규칙을 이용해서 for문으로 cnt만 ++ 주는 방식은 ?
1) input()
	// N <= 10^5 (== 100,000)
2) solve()
	// binary search 이용하기
	// for문으로 규칙이용해서 cnt++
	// 그 cnt 가 출력하고자 하는 인덱스랑 맞을 때 결과 저장 && break
	// 뭐 이런식으로 
3) 결과 출력 




#3 
// x 보다 작은 수를 찾으려면 (x-1 / 그 행) 을 하면 몇개 있는지 알 수 있음
// 이걸 이용해야 돼 

알고리즘은 아래와 같습니다.

1. 임의의 숫자 mid를 골라 mid보다 작은 숫자의 개수를 파악해서 K 번째 숫자를 구합니다.

2. mid는 이분 탐색으로 통해 구하고 low=1, high=K로 시작합니다.

3. mid보다 작은 숫자를 효과적으로 구하기 위해 1 ~ N까지 반복문을 돌리고 i * j <= mid이므로 (mid / i)가 조건을 만족하는 j의 숫자입니다.

->하지만, N이 1000보다 크면 mid / i 가 N보다 커질 수 있으므로 mid/i 와 N 중 작은 값을 더해 mid보다 작은 숫자의 개수를 파악합니다.

4. 이분 탐색을 마치면 원하는 숫자를 구할 수 있습니다.







// calculator
int cal(int m) {
	// m 보다 작은 수의 갯수를 구하고 싶으면
	// (m - 1) / 행 
	int cnt = 0;

	for (int i = 1; i <= N; i++) { 
		cnt += min(m / i, N); 
		// 봐 여기서 (m - 1) / i 까지는 맞는데 
		// N 즉, 배열에 끝보다 더 커질 수 있어 근데 
		// 배열보다 더 큰 거 넣어주면 안되잖아 최대가 N인데
		// 그래서 min() 을 사용하는 거야 
	}

	return cnt;
}	

// valid check
		// 앞에 6개 있는게 == 7이니까 // c == k -1
		// 그리고 작을 때도 정답 후보군이야
		// 근데 그럼 작은 애들 다 들어오잖아 그러니까 max 써야 돼





