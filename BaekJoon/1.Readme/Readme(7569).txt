// 토마토 (7569) Gold[5]




#1 // 터질 것 같음 ... 
1) input()
	// (들어오는 순서)M, N, H <= 100 // M 열, N 행
	// 익은 토마토 1, 익지 않은 토마토 0, 들어있지 않은 칸 -1
2) solve()
	// 2중 박스 갯수 for문 >> for문(vec[박스 갯수].size()) 
		>> Call BFS() >> 돌아올 때 queue 복사하면서 day++; 
		>> + 박스 위 아래로 번지는 거 처리해줘야 돼 
3) BFS()
	// 
4) Print day ! 
	// 토마토가 모두 익지 못하는 상황이면 -1 출력해야 함 
	// 저장 될 때 부터 모두 익어있는 상황이라면 0 출력해야 함 == input에서 부터 0 없을 때

※ 토마토가 앞, 뒤, 왼쪽, 오른쪽으로만 번지는게 아니라 상자 위 아래로도 번짐 ... ;;
※ 단, 토마토가 안들어 있을 수 있다.




#2 // 그냥 2차원 토마토랑 똑같이 푸는데 거기에 y, x 뿐 아니라 z를 추가해서 푸는 느낌으로 !
1) input()
2) solve()
	// BFS() start값을 모두 큐에 넣주고 시작
	// 갔다오면 day ++ ;
	// while(!que.empty()) 로 하고 하고 나왔는데도 안되면 -1
3) BFS() >> 2)
	// dir[2][4] 이렇게 했었는데 + 윗칸 아랫칸까지 포함해야함 
4) 결과 출력

※ input 때 익어야 하는 토마토 갯수 저장해 놨다가 익을 때 마다 체크해주고 다 되면 
	return  때리면 시간 조금이나마 줄일 수 있을 것 같다는 생각이 듬 

※ 토마토가 앞, 뒤, 왼쪽, 오른쪽으로만 번지는게 아니라 상자 위 아래로도 번짐 ... ;;
※ 단, 토마토가 안들어 있을 수 있다.



	