// 벽 부수고 이동하기 (2206) Gold[3] 설계 




#1 
1) input()
	// typedef struct 에 좌표(y, x) 랑 count + 벽 부술 수 있는 기회 1 
2) solve()
	// BFS()
3) BFS() 
	// 1, 1 에서 N, M 까지 Breadth-First Searching !
	// 벽 한 번 부수고 갈 수 있는 것 까지 판별해서 넣어보기
	// 도착했을 때 count return 하거나 저장
	// 목적지 N-1, M-1 인 거 잊지 말고 
4) 도착지 count 출력 !
	// 불가능 할 때는 -1 출력 !

※ 시작하는 칸과 끝나는 칸도 세야 된다는 것 인지하기 ! 




#2 (성공)
// used[][][] 3차원으로 만들어서 벽을 부술 때하고 안 부술 때를 구분해서 처리 해주어야 함 
// 이 문제에서 중요한 건 벽을 한 번 부술 수 있다는 것은 
// 벽을 부쉈을 때랑 안부쉈을 때랑 used 를 다르게 처리 해줘야 한다는 거인 것 같다 




# 반례
9 9
010001000
010101010
010101010
010101010
010101010
010101010
010101010
010101011
000100010
>> 33 나와야 함 

1 1
0
>> 1 나와야 함 




# 추가 반례 

2 4
0111
0010
>> 5

5 8
01000000
01010000
01010000
01010011
00010010
>> 20

8 8
01000100
01010100
01010100
01010100
01010100
01010100
01010100
00010100
>> 29

3 6
010000
010111
000110
>> 12

3 3
000
000
000
>> 5

4 4
0101
0101
0001
1110
>> 7




# 반례 모음 
5 5
01000
01010
01010
01011
00010
ans: 9

5 5
00000
11101
00001
01111
00010
ans: 15

5 5
01000
01010
01010
01011
00010
ans: 9

10 2
01
00
10
00
01
00
10
00
01
00
ans:13

5 5
00100
00000
10010
00101
00010
ans:9

9 9 
010001000
010101010
010101010
010101010
010101010
010101010
010101010
010101011
000100010
ans:33

6 6
010001
010101
010101
010101
010110
000110
ans:21

5 5
00100
11000
00110
01011
00000
ans:9

8 8
01000100
01010100
01010100
01010100
01010100
01010100
01010100
00010100
답 29
    

5 10
0000011000
1101011010
0000000010
1111111110
1111000000
답 14
    
    
5 5
01100
01000
01110
01000
00010
답 9
    
    
8 4
0000
0110
1110
0000
0111
0000
1110
0000
답 11
    
    
6 4
0000
1110
0110
0000
0111
0000
답 9
    
    
8 8
01000100
01010100
01010100
01010100
01010100
01010100
01010100
00010100
답 29

