4193. 수영대회 결승전 (완전 탐색 + 구현)

문제
N by N 크기에서 수영 대회 >> 공간 안에서 가장 빠른 길 찾아야 함
(장애물 존재 >> 섬 & 소용돌이 - 주기적으로 나타났다 사라졌다 함)
섬은 1, 소용돌이는 2 (소용돌이는 생성되고 2초 유지 >> 1초 잠잠)
ex) 0초에 생성 0, 1에 돌고 >> 2초에 사라짐 >> 다시 3, 4에 돌고 >> 5초에 사라짐
* 단 ,한번 통과한 소용돌이 위에서는 머물러 있을 수 있다 

가장 빠른 길로 수영 했을 때 몇 초만에 골인 할 수 있을까

도착 할 수 없다면 -1을 출력한다.


설계[1]
0 input 받기
1 struct { 현 위치, 다음 위치, 몇 초인지 }, queue<struct> 맹글기
2 함수 맹글기 
	init()
	BFS()
3 BFS() 돌면서 소용돌이 -1  >> if 0이 되면 다시 2로 
4 문제는 대기 했다가 가는 방법을 어떻게 해 ? ㅇㅅㅇ 구현


[input]
3  // test case
5  // N
0 0 0 0 0  // Map ...
0 0 0 1 0
0 0 0 1 0
2 2 1 1 0
0 0 0 0 0
4 0  // 시작점
2 0  // 도착점
6
0 0 0 0 0 0
0 1 1 0 0 0
0 0 0 1 2 0
1 1 0 1 0 1
0 0 0 1 0 1
0 0 0 2 0 1
5 0
2 5
6
0 0 0 0 0 0
0 0 0 0 0 0
1 0 1 1 1 0
1 0 0 0 0 0
1 0 1 1 1 0
0 0 2 0 2 0
5 0
3 5



[output]
#1 4  
#2 10
#3 7






// 1-1. BFS 기초 (Version. 인접행렬)
//9
//1 2
//1 7
//2 3
//3 4
//3 8
//4 5
//4 6
//8 9
#include <iostream>
#include <queue>
using namespace std;
int main()
{
    int arr[10][10] = { 0 };
    int node;
    cin >> node;

    // 1단계 : 그래프 구성
    for (int i = 0; i < node - 1; i++)
    {
        int from, to;
        cin >> from >> to;
        arr[from][to] = 1;
    }

    // 2단계 : queue 생성
    queue<int> q;            // queue에 넣는 정보 : node 정보

    // 3단계 : 시작노드 세팅
    q.push(1);                // 1번 노드가 시작점이므로 넣어줌

    // 7단계 : 4-6단계 반복
    while (!q.empty())        // queue가 비워질 때까지
    {
        // 4단계 : queue에서 node(=now) 하나 꺼냄
        int now = q.front();
        q.pop();

        // ------------------- 이번에 now를 들렸다. -------------------
        cout << now << " ";
        // ------------------------------------------------------------

        // 5단계 : now에서 갈 수 있는 node(=next)들 찾기
        for (int next = 1; next <= 9; next++)
        {
            if (arr[now][next] == 0) continue;        // now -> next로 가지 못하면 무시

            // 6단계 : next들을 queue에 추가
            q.push(next);
        }
    }

    return 0;
}



























