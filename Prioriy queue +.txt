Prioriy queue
// https://www.youtube.com/watch?v=AjFlp951nz0
// https://jungeu1509.github.io/algorithm/use-priorityqueue/



# 0 (정의)
우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조  
// 일반 큐는 먼저 들어간 데이터가 먼저 나오지만 
// 우선순위 큐는 우선순위가 높은 데이터가 먼저 나오는 자료구조 
// 기본이 DESC 으로 정렬 됨 



# 1 (멤버 함수 종류)
#include <queue> 에 들어 있음
- empty
- size
- top
- push
- emplace // Priority queue 에 구조 삽입
- pop
- swap // 두 개의 pq를 swap 함



# 2 (사용 예시)
priority_queue<pair<int, int>> pq;
pq.emplace(1, 2); // 값을 push
pq.push(1, 2); // 오류남 
pq.push(make_pair(2, 3)); // push 사용할 때는 pair 만들어 주고 해야 됨 
while(!pq.empty()){
    pair p = pq.top();
    cout << p.first << "\n";	<< 2 다음 1
    cout << p.second << "\n";	<< 3 다음 2
    pq.pop();
}

@ 주의사항 pair 사용하려면 >> #include <utility> 라이브러리 사용해야 함 



# 3 (쉬운 예시)
priority_queue<int> pq;
pq.push(5);
pq.push(3);
pq.push(6);
pq.push(1);
pq.push(2);
while(!pq.empty()){
    int tmp = pq.top();
    pq.pop();
    cout << tmp << "\n";
} 
// 결과 6 5 3 2 1 .. 
// 기본이 DESC 으로 정렬, 출력 됨 



# 4 (활용)
1) 다른 선언
priority_queue<자료형, 구현체, 비교연산자> pq;

2) 작은 수 우선 (ASC) 으로 배치
비교연산자 부분에 greater<int> 삽입 

3) 비교 연산자 사용하기 
비교연산자 부분에 compare 함수 하나 만들어서 하면 됨 sort 할 때 처럼 ... 
priority_queue <int, vector<int>, cmp> pq;
struct compare {
  bool operator()(int a, int b) {
    return a > b;
  }
};

4) 구조체 활용하기 
typedef struct{
	int i, char c;
}node;
// 생성자
node(int num, char alpha) : i(num), c(alpha) {}

struct compare {
  bool operator()(node a, node b) {
    // int형의 값이 같을 경우
    if(a.i == b.i) {
      // char형의 값이 큰 것이 우선하도록한다.
      return a.c < b.c;
    }
    // int형의 값이 작은 것이 우선하도록한다.
    return a.i > b.i;
  }
};

priority_queue <node, vector<node>, compare> pq;

pq.push(s(3, 'a'));
pq.push(s(4, 'b'));
pq.push(s(5, 'y'));
pq.push(s(3, 'z'));
pq.push(s(100, 'z'));

node temp;
cout << temp.i << tem.c;
// 출력결과 
// 3 z
// 3 a
// 4 b
// 5 y
// 100 z








