// 배낭 알고리즘 [knapsack algorithm]


※ DP 문제 DFS로 풀면 시간 초과 남


# 기본 이론
0-1 knapsack problem
limit = 5
	A	B	C	D
v	30	20	40	10
w	1	2	3	4
bruteforce 시간 복잡도 == 2^n

NS("A B C D", 5)
점화식
NS(n, w) = max = { ns(n-1, w-w[n]) + v[n] // 골랐을 때
			ns(n-1, w) + 0 // 안 골랐을 때

[NS]
	0	1	2	3	4	5	// 가방한도
0	0	0	0	0	0	0
A	0	30	30	30	30	30
B	0	30	30	50	50	50
C	0	30	30	50	70	70
D	0	30	30	50	70	70 << 답

※ 점화식 max(DP[i-1][j], DP[i-1][j-W[i]])
DP[i][j] = max(DP[i - 1][j], DP[i - 1][j - W[i]] + V[i]);





EX) 심화 (BOJ 12865)
종류 : 4 
무게 : 7
A 6 13
B 4 8
C 3 6
D 5 12

ABCD	w, v
0000	0, 0
0001	5, 12
0010	3, 6
0011	8, 18 x (뒤가 11일 때 할 필요 없는거야 이미 넘어갔잖아)
0100	4, 8
0101	9, 20 x (여기도 넘었어 101도 안돼)
0110	7, 14
0111	x
여기서 부턴 맨 앞만 다르고 뒤가 다르잖아 그러니까 v + 6 w +13 하면 됨
1000	6, 13
1001	11, 25 x
1010	9, x
1011 	x
1100	10, x
1101	x
1110	x
1111	x

뒤로 갈 수록 계산 안해줘도 되는 것들이 있는거야 
x 나온 것들은 계산을 할 필요가 없잖아
그래서 w 배열만 만들고 하는거지 

		[i]
w	A	B	C	D
0	0	0	0	0
1	0	0	0	0	
2	0	0	0	0
3	0	0	6	6	[j] 
4	0	8	8	8
5	0	0	0	12
6	13	13	13 	13	// (무게가 6이고 가치가 13일 때)
7	0	0	14	14
테이블이 왜 7까지겠어 ? 7이상 어차피 못 담잖아 (가방 한도)
7이라는 한계치를 정하고 채워 넣으니까 많이 줄일 수 있는거지 
각각에 대해서 넣고 뺐을 때 가장 큰 값 뽑으면 == 14 그게 답임 

w = [6, 4, 3, 5]
v = [13, 8, 6, 12]

table[i][j+w[i]] = table[i - 1][j] + v[i]
>> table[i][j+w[i]] = max(table[i-1][j+w[i]], table[i - 1][j] + v[i])
>>	넣어줌       = 중 더 큰거 (기존에 있던 값, 다음 값)
