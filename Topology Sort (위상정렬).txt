Topology Sort (위상정렬)



※ 위상이나 위상수학이란 ?
수학자가 아닌 일반인에게 위상수학(位相數學, topology)이 무엇을 연구하는 학문인지 설명할 때 가장 많이 쓰는 예시는 손잡이가 있는 컵과 도넛, 그리고 안이 꽉 찬 찰흙공과 접시의 같음과 다름을 구분하는 것이다.



# 위상 정렬 (Topology Sort) 란 ?
'순서가 정해져 있는 작업'을 차례로 수행해야 할 때,
그 순서를 결정해주기 위해 사용하는 알고리즘 입니다.
(여러개의 답이 존재 할 수 있다는 점)


# 위상 정렬이 되기 위한 조건 
DAG(Directed Acyclic Graph) 에만 적용 가능
즉, 방향 그래프인데, 사이클이 발생하지 않는 그래프 에만 적용이 가능함 


# 두 가지 해결책을 낸다는 특징
1) 현재 그래프는 위상 정렬이 가능한지 아닌지
2) 위상정렬이 가능하다면 그 결과가 무엇인지 


# 사용 자료구조
1) Stack(스택) 이용하기
2) Queue(큐) 이용하기 (더 많이 사용됨)


# 방식
1) 진입차수가 0인 정점을 큐에 삽입한다
// 진입차수가 0 == 조건이 없는 애들 == 본인 전에 수행되어야 할게 없는 애들 == 시작점
2) 큐에서 원소를 꺼내 연결된 모든 간선을 제거
3) 간선 제거 이후에 진입차수가 0이 된 정점을 큐에 삽입
4) 큐가 빌 때까지 2)~3)번 과정 반복 
// 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재 == 위상 정렬 x
// 모든 원소를 방문했다면 큐에서 꺼낸 순서가 위상 정렬의 결과 !


Ex)
  -> 2 -> 3 -> 4
1	     /
	    v
  -> 5 -> 6 -> 7  
// 4 -> 6 임

정점	1 2 3 4 5 6 7
진입차수 0 1 1 1 1 2 1 // 진입차수가 몇 개인지야
// 이러면 queue에 1번 넣어줘야지 
// 1번 queue에서 꺼내서 간선 제거
빼 놓은 값 1

// 그러면
정점	1 2 3 4 5 6 7
진입차수 0 0 1 1 0 2 1 
// 이렇게 바뀌겠지
// 그럼 다시 2 5 queue에 넣고 
// 2번 5번 queue에서 꺼내서 간선 제거 반복이야
빼 놓은 값 1 2 5

... 
반복하면 결국

빼 놓은 값 1 2 5 3 4 6 7 이게 위상 정렬임 



# 간단한 코드 (C++)
1) vector[2차원] <- 간선 담을 꺼, queue, result[배열], 
	// Degree[배열] <- 진입차수 몇 개인지 적어놓을 친구
2) 진입 차수가 0인 노드 큐에 삽입
3) for( N(노드 갯수)) N개 노드 방문
	if(모두 방문하기 전에 큐가 빈다면 == 사이클 발생 == 위상 정렬 못해)
	else {
		now = q.front 꺼내
		q.pop
		result[i] = now // 왜 ? 큐에서 꺼낸 순서가 위상 정렬 결과니까
		
		for( i < vec[now].size() ){
			int idx = vec[now][i]
			int next = Degree[idx] - 1 // 간선제거 한 값
			
			if(next == 0){
				// 간선을 제거해 보니 진입차수 없는 친구 발생
				// 그러면 다시 그 친구들 queue 에 삽입
				q.push(next);
			}
		}
	}
4) result[배열] << 출력하면 끝 !



