// 조립 라인 문제 설계 (may be... DP)



#1 문제 이해하기 

A - 작업장 N개 - Ai(작업장) - A1(최초 조립 작업장) 
	- Ai 작업장에서 작업이 종료되면 Ai+1 작업장에서 작업을 시작할 수 있

B - 작업장 N개 - Bi(작업장) - 동일한대 - 작업장 옮겨서 조립 가능
					but 옮길 때 이동시간 추가 됨 

# input
2		// 작업장의 수 
1 3 1 2		// Ai 작업장의 작업시간, Bi 작업장의 작업시간
		// Ai 작업장에서 Bi+1 작업장까지 이동시간, B -> A 이동시간
10 2 		// An 작업장과 Bn 작업장의 작업시간

# output
4		// 첫 번째 줄에 가장 빠른 조립시간 출력



#2 문제 이해하기 !
N * N 의 경우의 수가 있는데 예제는 N이 2라서 모든 경우의 수 해도 4라서 상관없는데,
입력이  1 <= N <= 10^3(1,000) 까지 들어올 수 있기 때문에 시간초과 우려가 있음 
== O(2^N) == 10^300 정도 됨 == 시간초과 

N == 3일 때
input
3
// A, B 의 각각 작업장 수 
1 3 1 2		
// 첫번째 작업장 A1 == 1, B1 == 3 &&
// 이동시간 A1->B2 == 1, B1->A2 == 2
10 2 2 1
// 첫번째 작업장 A2 == 10, B2 == 2 &&
// 이동시간 A2->B3 == 2, B2->A3 == 1
2 2		
// 마지막 작업장 A3 == 2, B3 == 2

우리 각각 작업장에서 2가지 경우만 생각하면 되잖아 그 중에서도 빨리 끝나는 거 중에 작은 거
작은 거만 가지고 가는 느낌으로 가지치기를 해서 풀어야 되는 것
즉, A기준 두번째 작업장 부터는 들어올 수 있는 경우가 A에서 오는 거 B에서 오는 거
2가지니까 둘 중 작은 거 저장하고 이런 식으로 풀어야 한다는 거야 



#3
1) input()
	// N <= 10^3
	// A, B 배열 만들고 (vector 도 고려)
2) solve()
	// 일단 처음 작업장 A,B 의 1작업장 값 넣고 시작 
	for(N만큼){
	// 여기서 인덱스 1씩 증가시키면서 A, B 배열 각각 갱신
	// Searching 하는 Funtion 만들고 인스턴스 (지금 작업장 어딘지 : for문의 i)
	}
3) Searching Funtion
	// 여기서 A, B 배열 이전꺼와 경우의 수 확인해서 어느게 최소 값인지 갱신해줘 
4) 다시 solve()
	// 반복
5) 끝났을 때 각각 배열 마지막에 있는 것 중에 더 작은 거 출력 










