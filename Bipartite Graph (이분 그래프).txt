Bipartite Graph (이분 그래프) && Bipartite Matching (이분 매칭)


인접한 정점끼리 서로 다른 색으로 칠해서 모든 정점을 두 가지 색으로만 칠 할 수 있는 그래프
Ex) 빨간색, 파란색 두가지 있으면 빨강색은 파란색으로만 연결되어 있어야 되고
	파란색은 빨간색으로만 연결 되어있어야 되는 거지 

즉, 그래프의 모든 정점이 두 그룹으로 나눠지고 서로 다른 그룹의 정점이 간선으로 연결되어
있는 (같은 그룹에 속한 정점끼리는 서로 인접하지 않도록 하는) 그래프를 이분 그래프 라고 한다


Ex) 이분 그래프
V 3 (Vertex : 정점, 노드) 
E 2 (Edge : 모서리, 간선)
1 3
2 3
1 - 3	이렇게 연결이 되겠지
2 - 
BFS 돌면 
1(빨) -> 3(파)
3(파) -> 2(빨) 
이러면 이분 그래프인 거지
즉, BFS 돌면서 색을 계속 바꿔가면서 칠해줘야 되는거지
근데 하다가 이미 칠해진 친구 만날 수도 있잖아 그럼 que 에 넣을 필요가 없는거지 
(이건 의문, 방금 빨강 칠하고 왔는데 파랑으로 칠해져 있으면 상관 없는건데 
방금 빨강 칠하고 왔는데 빨강으로 칠해져 있어 이러면 안되는거지 ? ) 


Ex) 이분 매칭
동민 민수 수진이가 노트북 A B C 를 선택할 껀데 
동민이는 A, B, C 다 좋아하고 민수는 A만 수진이는 C만 좋아하는 경우
DFS로 탐색하는 거지 먼저 동민이가 A 를 골랐다가 민수가 A하고 싶으면 동민이한테
물어보는 거지 A 말고 다른 거 고를 수 없어 ? 그래서 동민이가 B로 바꿔 
이런 식으로 해서 (Used) 안 겹치게 해서 하면 되는 건데 
이게 두 그룹으로 나눠지는지 확인하는 것을 이분 매칭이라고 함 
vec[1(동민)].push_back(1(A노트북));
vec[1(동민)].push_back(2(B노트북));
vec[1(동민)].push_back(3(C노트북));
vec[2(민수)].push_back(1(A노트북));
vec[3(수진)].push_back(3(C노트북));



